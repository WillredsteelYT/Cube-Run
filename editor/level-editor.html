<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Editor</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #222;
            color: white;
        }

        #editorCanvas {
            border: 2px solid #fff;
            background-color: #333;
        }

        #menu {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 800px;
            padding: 10px;
            background-color: #444;
            border-top: 2px solid #fff;
        }

        .menu-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .menu-section img {
            width: 50px;
            height: 50px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border 0.2s;
        }

        .menu-section img.selected {
            border: 2px solid #fff;
        }

        button {
            padding: 10px 20px;
            background-color: #555;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #666;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Level Editor</h1>
    <canvas id="editorCanvas" width="800" height="400"></canvas>
    <div id="menu">
        <div class="menu-section">
            <img src="assets/block.png" alt="Block" id="blockTool" class="tool" data-type="block">
            <img src="assets/spike.png" alt="Spike" id="spikeTool" class="tool" data-type="spike">
        </div>
        <div class="menu-section">
            <button id="exportLevel">Export Level</button>
            <button id="importLevel">Import Level</button>
            <button id="deleteButton">Delete</button>
            <button id="clearCanvas">Clear</button>
            <input type="file" id="fileInput" accept=".cbr">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d');
        const blockTool = document.getElementById('blockTool');
        const spikeTool = document.getElementById('spikeTool');
        const exportLevelButton = document.getElementById('exportLevel');
        const importLevelButton = document.getElementById('importLevel');
        const deleteButton = document.getElementById('deleteButton');
        const clearCanvasButton = document.getElementById('clearCanvas');
        const fileInput = document.getElementById('fileInput');

        const gridSize = 40; // Size of each grid cell
        let selectedTool = null; // Currently selected tool (block or spike)
        const placedObjects = []; // Array to store placed blocks and spikes
        let selectedObjects = []; // Array to store selected objects for deletion

        // Add event listeners to tool buttons
        [blockTool, spikeTool].forEach(tool => {
            tool.addEventListener('click', () => {
                // If the tool is already selected, unselect it
                if (tool.classList.contains('selected')) {
                    tool.classList.remove('selected');
                    selectedTool = null;
                } else {
                    // Otherwise, select the clicked tool and unselect others
                    document.querySelectorAll('.tool').forEach(t => t.classList.remove('selected'));
                    tool.classList.add('selected');
                    selectedTool = tool.dataset.type;
                    selectedObjects = []; // Clear any selected objects
                }
            });
        });

        // Add event listener to canvas for selecting and placing objects
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / gridSize) * gridSize;

            // If no tool is selected, try selecting an object
            if (!selectedTool) {
                const clickedObject = placedObjects.find(obj =>
                    x >= obj.x && x < obj.x + gridSize &&
                    y >= obj.y && y < obj.y + gridSize
                );

                if (clickedObject) {
                    const isCtrlPressed = e.ctrlKey || e.metaKey; // Check if Ctrl or Command key is held
                    if (isCtrlPressed) {
                        // If Ctrl is held, toggle selection
                        if (selectedObjects.includes(clickedObject)) {
                            selectedObjects = selectedObjects.filter(obj => obj !== clickedObject);
                        } else {
                            selectedObjects.push(clickedObject);
                        }
                    } else {
                        // If Ctrl is not held, select only this object
                        selectedObjects = [clickedObject];
                    }
                } else {
                    // If no object is clicked, clear selection
                    selectedObjects = [];
                }

                // Redraw to show current selection
                drawObjects();
                return;
            }

            // Add a new object if a tool is selected
            placedObjects.push({ type: selectedTool, x, y });
            drawObjects();
        });

        // Draw all placed objects on the canvas
        function drawObjects() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            drawGrid();

            // Draw each object
            placedObjects.forEach(obj => {
                if (obj.type === 'block') {
                    ctx.fillStyle = '#000'; // Black for blocks
                    ctx.fillRect(obj.x, obj.y, gridSize, gridSize);
                } else if (obj.type === 'spike') {
                    ctx.fillStyle = '#000'; // Black for spikes
                    ctx.beginPath();
                    ctx.moveTo(obj.x, obj.y + gridSize);
                    ctx.lineTo(obj.x + gridSize / 2, obj.y);
                    ctx.lineTo(obj.x + gridSize, obj.y + gridSize);
                    ctx.closePath();
                    ctx.fill();
                }

                // Highlight selected objects
                if (selectedObjects.includes(obj)) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obj.x, obj.y, gridSize, gridSize);
                }
            });
        }

        // Draw grid on the canvas
        function drawGrid() {
            ctx.strokeStyle = '#555';
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Delete selected objects
        deleteButton.addEventListener('click', () => {
            if (selectedObjects.length > 0) {
                selectedObjects.forEach(obj => {
                    const index = placedObjects.indexOf(obj);
                    if (index !== -1) {
                        placedObjects.splice(index, 1);
                    }
                });
                selectedObjects = []; // Clear selection after deleting
                drawObjects();
            } else {
                alert('No objects selected for deletion!');
            }
        });

        // Export level as a .cbr file
        exportLevelButton.addEventListener('click', () => {
            const levelData = JSON.stringify(placedObjects);
            const blob = new Blob([levelData], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'level.cbr';
            a.click();
        });

        // Import level from a .cbr file
        importLevelButton.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        if (Array.isArray(importedData)) {
                            placedObjects.length = 0;
                            placedObjects.push(...importedData);
                            drawObjects();
                        } else {
                            alert('Invalid file format!');
                        }
                    } catch (err) {
                        alert('Error reading file!');
                    }
                };
                reader.readAsText(file);
            }
        });

        // Clear the canvas and reset objects
        clearCanvasButton.addEventListener('click', () => {
            placedObjects.length = 0;
            selectedObjects = [];
            drawObjects();
        });

        // Initialize the editor by drawing the grid
        drawGrid();
    </script>
</body>
</html>